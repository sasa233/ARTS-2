这里列出了自己对于 Java 中接口和抽象类的对比：

- 共同点：

  - 都可定义方法、属性；
  - 都可以没有抽象方法；
    - 没有任何方法接口称为 Marker Interface，其目的是作为一种标志，如 `Serializable` 接口。
  - 都不能实例化。

- **不同点**：

  | 对比项       | 抽象类                                                       | 接口                                                         |
  | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 继承         | 单继承                                                       | 可实现多个接口，但接口可**继承**多个接口                     |
  | 构造方法     | 可有                                                         | 不可有                                                       |
  | `main()`方法 | 可有、可执行                                                 | 不可有                                                       |
  | 属性修饰符   | 自定义                                                       | 默认`public static final`                                    |
  | 静态代码块   | 可有                                                         | 不可有                                                       |
  | 方法         | 1.抽象方法必须是`public`(默认)或`protected`：否则不能被子类继承；<br/> 2.可有非抽象方法；<br/> 3.可有静态方法 | 1.默认 `public abstract`；<br/>2.JDK1.8后可有默认方法(`default`修饰，不能私有，有方法体)；<br/>3.JDK1.8后可有静态方法； <br/>4.JDK1.9后可有私有方法 |

  - 接口的默认方法：
    - 引入：JDK1.8以前，在接口中添加一个方法，所有接口实现类都要去实现，而部分实现类即使不需要这一功能也必须有一个空实现。接口的默认方法就是为了解决这一问题。
    - 接口的默认方法以`default`修饰（该关键字只能用在接口中）。
    - 如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。
  - 接口的私有方法：
    - 引入：如果一个接口中多个默认方法中有大量代码相同时怎么办？由于默认方法不能私有化，所以无法抽取出重复代码，而私有辅助方法则是为了解决这一问题。